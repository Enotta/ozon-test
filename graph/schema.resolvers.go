package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"ozon-test/graph/model"
	"reflect"
	"strconv"
	"time"
)

// Checks if list is Slice or Array and contains structs with ID field and validate that field.
func validateLocal(list interface{}, id string) bool {
	val := reflect.ValueOf(list)
	if val.Kind() != reflect.Slice && val.Kind() != reflect.Array {
		return false
	}

	for i := 0; i < val.Len(); i++ {
		elem := val.Index(i)

		if elem.Kind() == reflect.Ptr {
			elem = elem.Elem()
		}

		idField := elem.FieldByName("ID")
		if !idField.IsValid() || idField.Kind() != reflect.String {
			continue
		}

		if idField.String() == id {
			return true
		}
	}

	return false
}

// Make sure to have authors table
func secureAuthor(db *sql.DB) error {
	_, err := db.Exec(`
		CREATE TABLE IF NOT EXISTS authors (
			id SERIAL PRIMARY KEY,
			username VARCHAR(50) NOT NULL
		);
	`)

	return err
}

// Make sure to have posts table
func securePost(db *sql.DB) error {
	_, err := db.Exec(`
		CREATE TABLE IF NOT EXISTS posts (
			id SERIAL PRIMARY KEY,
			title VARCHAR(255) NOT NULL,
			content VARCHAR(2000) NOT NULL,
			author INT NOT NULL REFERENCES authors(id),
			comments_enabled BOOLEAN NOT NULL DEFAULT TRUE,
			created_at TIMESTAMP
		);
	`)

	return err
}

// Make sure to have comments table
func secureComment(db *sql.DB) error {
	_, err := db.Exec(`
		CREATE TABLE IF NOT EXISTS comments (
			id SERIAL PRIMARY KEY,
			content VARCHAR(2000) NOT NULL,
			author INT NOT NULL REFERENCES authors(id),
			post_id INT NOT NULL REFERENCES posts(id),
			parent_id INT,
			created_at TIMESTAMP,
			FOREIGN KEY (parent_id) REFERENCES comments(id)
		);
	`)

	return err
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input model.NewPost) (*model.Post, error) {
	switch r.Storage {
	case InMemory:
		// cant create post if author doesnt exist
		if !validateLocal(r.authors, input.Author) {
			return nil, errors.New("no valid author found")
		}

		post := &model.Post{
			ID:              fmt.Sprintf("%d", len(r.posts)+1),
			Title:           input.Title,
			Content:         input.Content,
			Author:          input.Author,
			CommentsEnabled: input.CommentsEnabled,
			CreatedAt:       time.Now().GoString(),
		}
		r.posts = append(r.posts, post)
		return post, nil

	case Postgres:
		err := secureAuthor(r.Connection)
		if err != nil {
			return nil, err
		}
		err = securePost(r.Connection)
		if err != nil {
			return nil, err
		}

		author, err := strconv.Atoi(input.Author)
		if err != nil {
			return nil, err
		}
		rows, err := r.Connection.Query(
			`INSERT INTO posts (
				title,
				content,
				author,
				comments_enabled,
				created_at
			) 
			values ($1, $2, $3, $4, $5) RETURNING *;`,
			input.Title,
			input.Content,
			author,
			input.CommentsEnabled,
			time.Now(),
		)
		if err != nil {
			return nil, err
		}

		defer rows.Close()
		var post model.Post
		for rows.Next() {
			err = rows.Scan(&post.ID, &post.Title, &post.Content, &post.Author, &post.CommentsEnabled, &post.CreatedAt)
			if err != nil {
				return nil, err
			}
		}
		return &post, nil

	default:
		return nil, nil
	}
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, input model.NewComment) (*model.Comment, error) {
	switch r.Storage {
	case InMemory:
		// cant create post if author, post, parent doesnt exist
		if !validateLocal(r.authors, input.Author) {
			return nil, errors.New("no valid author found")
		} else if !validateLocal(r.posts, input.PostID) {
			return nil, errors.New("no valid author found")
		} else if input.ParentID != nil && !validateLocal(r.comments, *input.ParentID) {
			return nil, errors.New("no valid author found")
		}

		commentsEnabled := true
		for i := 0; i < len(r.posts); i++ {
			if input.PostID == r.posts[i].ID {
				if !r.posts[i].CommentsEnabled {
					commentsEnabled = false
				}

				break
			}
		}

		var comment model.Comment
		if commentsEnabled {
			comment = model.Comment{
				ID:        fmt.Sprintf("%d", len(r.comments)+1),
				Content:   input.Content,
				Author:    input.Author,
				PostID:    input.PostID,
				ParentID:  input.ParentID,
				CreatedAt: time.Now().GoString(),
			}
			r.comments = append(r.comments, &comment)
		}

		return &comment, nil

	case Postgres:
		err := secureAuthor(r.Connection)
		if err != nil {
			return nil, err
		}
		err = secureComment(r.Connection)
		if err != nil {
			return nil, err
		}
		err = securePost(r.Connection)
		if err != nil {
			return nil, err
		}

		author, err := strconv.Atoi(input.Author)
		if err != nil {
			return nil, err
		}
		post_id, err := strconv.Atoi(input.PostID)
		if err != nil {
			return nil, err
		}
		parent_id := 0
		if input.ParentID != nil {
			parent_id, err = strconv.Atoi(*input.ParentID)
			if err != nil {
				return nil, err
			}
		}
		if parent_id == 0 { // root comment
			rows, err := r.Connection.Query(
				`INSERT INTO comments (content, author, post_id, parent_id, created_at)
				SELECT 
					$1,
					$2,
					$3,
					$4,
					$5
				FROM posts
				WHERE 
					id = $6
					AND comments_enabled = TRUE 
				RETURNING *;`,
				input.Content,
				author,
				post_id,
				nil,
				time.Now(),
				post_id,
			)
			if err != nil {
				return nil, err
			}

			defer rows.Close()
			var comment model.Comment
			for rows.Next() {
				err = rows.Scan(&comment.ID, &comment.Content, &comment.Author, &comment.PostID, &comment.ParentID, &comment.CreatedAt)
				if err != nil {
					return nil, err
				}
			}
			return &comment, nil
		} else { // reply to any otherr comment
			rows, err := r.Connection.Query(
				`INSERT INTO comments (content, author, post_id, parent_id, created_at)
				SELECT 
					$1,
					$2,
					$3,
					$4,
					$5
				FROM posts
				WHERE 
					id = $6
					AND comments_enabled = TRUE 
				RETURNING *;`,
				input.Content,
				author,
				post_id,
				parent_id,
				time.Now(),
				post_id,
			)
			if err != nil {
				return nil, err
			}

			defer rows.Close()
			var comment model.Comment
			for rows.Next() {
				err = rows.Scan(&comment.ID, &comment.Content, &comment.Author, &comment.PostID, &comment.ParentID, &comment.CreatedAt)
				if err != nil {
					return nil, err
				}
			}
			return &comment, nil
		}

	default:
		return nil, nil
	}
}

// CreateAuthor is the resolver for the createAuthor field.
func (r *mutationResolver) CreateAuthor(ctx context.Context, input model.NewAuthor) (*model.Author, error) {
	switch r.Storage {
	case InMemory:
		author := &model.Author{
			ID:       fmt.Sprintf("%d", len(r.authors)+1),
			Username: input.Username,
		}
		r.authors = append(r.authors, author)
		return author, nil

	case Postgres:
		err := secureAuthor(r.Connection)
		if err != nil {
			return nil, err
		}

		rows, err := r.Connection.Query(`INSERT INTO authors (username) values ($1) RETURNING *;`, input.Username)
		if err != nil {
			return nil, err
		}

		defer rows.Close()
		var author model.Author
		for rows.Next() {
			err = rows.Scan(&author.ID, &author.Username)
			if err != nil {
				return nil, err
			}
		}
		return &author, nil

	default:
		return nil, nil
	}
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context) ([]*model.Post, error) {
	switch r.Storage {
	case InMemory:
		return r.posts, nil
	case Postgres:
		var posts []*model.Post

		err := securePost(r.Connection)
		if err != nil {
			return nil, err
		}

		rows, err := r.Connection.Query(
			`SELECT * FROM posts;`,
		)
		if err != nil {
			return nil, err
		}

		defer rows.Close()
		for rows.Next() {
			var post model.Post
			err = rows.Scan(&post.ID, &post.Title, &post.Content, &post.Author, &post.CommentsEnabled, &post.CreatedAt)
			if err != nil {
				return nil, err
			}

			posts = append(posts, &post)
		}
		return posts, nil
	default:
		return nil, nil
	}
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	switch r.Storage {
	case InMemory:
		var post *model.Post

		for i := 0; i < len(r.posts); i++ {
			if r.posts[i].ID == id {
				post = r.posts[i]

				break
			}
		}

		return post, nil
	case Postgres:
		err := securePost(r.Connection)
		if err != nil {
			return nil, err
		}

		intId, err := strconv.Atoi(id)
		if err != nil {
			return nil, err
		}
		rows, err := r.Connection.Query(
			`SELECT * FROM posts WHERE id = $1;`,
			intId,
		)
		if err != nil {
			return nil, err
		}

		defer rows.Close()
		var post model.Post
		for rows.Next() {
			err = rows.Scan(&post.ID, &post.Title, &post.Content, &post.Author, &post.CommentsEnabled, &post.CreatedAt)
			if err != nil {
				return nil, err
			}
		}
		return &post, nil
	default:
		return nil, nil
	}
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
