package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"errors"
	"fmt"
	"ozon-test/graph/model"
	"reflect"
	"time"
)

// Checks if list is Slice or Array and contains structs with ID field and validate that field.
func validateLocal(list interface{}, id string) bool {
	val := reflect.ValueOf(list)
	if val.Kind() != reflect.Slice && val.Kind() != reflect.Array {
		return false
	}

	for i := 0; i < val.Len(); i++ {
		elem := val.Index(i)

		if elem.Kind() == reflect.Ptr {
			elem = elem.Elem()
		}

		idField := elem.FieldByName("ID")
		if !idField.IsValid() || idField.Kind() != reflect.String {
			continue
		}

		if idField.String() == id {
			return true
		}
	}

	return false
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input model.NewPost) (*model.Post, error) {
	switch r.Storage {
	case InMemory:
		if !validateLocal(r.authors, input.Author) {
			return nil, errors.New("no valid author found")
		}

		post := &model.Post{
			ID:              fmt.Sprintf("%d", len(r.posts)+1),
			Title:           input.Title,
			Content:         input.Content,
			Author:          input.Author,
			CommentsEnabled: input.CommentsEnabled,
			CreatedAt:       time.Now().GoString(),
		}
		r.posts = append(r.posts, post)
		return post, nil
	case Postgres:
		return nil, nil
	default:
		return nil, nil
	}
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, input model.NewComment) (*model.Comment, error) {
	switch r.Storage {
	case InMemory:
		if !validateLocal(r.authors, input.Author) {
			return nil, errors.New("no valid author found")
		} else if !validateLocal(r.posts, input.PostID) {
			return nil, errors.New("no valid author found")
		} else if input.ParentID != nil && !validateLocal(r.comments, *input.ParentID) {
			return nil, errors.New("no valid author found")
		}

		comment := &model.Comment{
			ID:       fmt.Sprintf("%d", len(r.comments)+1),
			Content:  input.Content,
			Author:   input.Author,
			PostID:   input.PostID,
			ParentID: input.ParentID,
		}
		r.comments = append(r.comments, comment)
		return comment, nil
	case Postgres:
		return nil, nil
	default:
		return nil, nil
	}
}

// CreateAuthor is the resolver for the createAuthor field.
func (r *mutationResolver) CreateAuthor(ctx context.Context, input model.NewAuthor) (*model.Author, error) {
	switch r.Storage {
	case InMemory:
		author := &model.Author{
			ID:       fmt.Sprintf("%d", len(r.authors)+1),
			Username: input.Username,
		}
		r.authors = append(r.authors, author)
		return author, nil
	case Postgres:
		return nil, nil
	default:
		return nil, nil
	}
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context) ([]*model.Post, error) {
	panic(fmt.Errorf("not implemented: Posts - posts"))
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	panic(fmt.Errorf("not implemented: Post - post"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
